## 前言

垃圾回收从上世纪50年代就被提出，经过几十年的研究和沉淀，不断改进和进步，如今已经非常成熟，可以轻松管理TB级别内存，也可以在嵌入式中保证1ms内响应的硬实时性能。本篇用来对GC算法进行简单介绍，以及记录学习的心得。

本科做嵌入式程序的时候发现，单片机编程领域仅能接触到C/C++等无GC的语言，而手动内存管理带来的风险和不确定性却常常成为编程的一大隐患。缘此有了一个长期疑问：为什么有GC的语言很难在嵌入式设备上运行？是否可以做一个能在嵌入式设备上运行的GC呢？个人学习研究许久，终于总结了一些知识，现希望和大家交流分享。

## 什么是GC？

GC--Garbage Collection, 字面意思上说是垃圾回收， 垃圾是什么呢？为什么要回收呢？

### 什么是垃圾？

我的理解--广义的来说， 程序运行阶段会不停的申请资源， 释放资源， 当资源不再使用，但占用的资源未被释放，这些就成为垃圾。 常用的垃圾有，内存， 硬盘， 网络等等。 

现代计算机的体系架构中，内存是程序运行时的主存储器，容量和传输速度都并不足够，即使有CPU内的多级缓存技术和操作系统的页面置换技术，也仍然可能成为系统整体性能的瓶颈。而在编程语言层面，物理地址上线性排布的内存的逻辑关系上，却是以有向图的形式存在，动态的运行下，内存中不可避免的会出现无法被程序引用的内存块，也就是垃圾。程序需要及时清理垃圾，再重新分配，才能保证内存资源不会被垃圾占满而导致程序崩溃。

### 为什么需要研究垃圾回收？

内存资源内部引用关系复杂，可以看做有向图结构，内存块是否是垃圾需要根据程序是否能引用到来判断，因此不存在O(1)的方法直接判断某个地址是垃圾，因此垃圾回收会造成额外开销。
其次，如果是批处理的进行垃圾回收过程，会导致程序的暂停，程序一段时间无法响应。许多场景下这个问题十分致命。
再其次，总是需要为程序申请的内存预留空间，预留空间较少会导致GC频繁，影响吞吐量；预留空间过大又会导致暂停时间过长，此外成本也会增加。
如果是手动管理内存，一旦遇到内存问题会严重影响程序稳定性，增加开发和维护成本，并且难以进行排查定位。

因此，如果垃圾回收处理不当将会大大影响程序的开发、维护，也会影响程序的效率，硬件成本。针对这些问题而研究和开发出各种GC算法，当工程使用时选择并配置好合理的算法，才能做出最优的开发决策。

### 垃圾回收的功能

虽然名字是垃圾回收，但实际上的功能不仅限于垃圾回收本身，垃圾回收常常还包括许多其他功能：
+ 内存资源的分配功能，包括选择分配算法及分配时的额外任务(如触发GC等)
+ 存活资源的移动和重新排列，使空闲内存连续空间，减少分配开销；使相关资源排列更紧密，提高CPU缓存效率
+ 垃圾回收的额外任务(如C++的析构函数等)
+ 向操作系统申请和归还内存池，程序分配时从内存池分配而非直接操作系统调用，降低开销
+ 引用或指针的特殊管理(如使用指针本身比特位记录信息、对象移动时更新引用、读写屏障等)
大多的垃圾回收包括上面的部分或全部功能，以至于实际是一套完整的内存管理框架。

## 垃圾回收算法的分类

基于垃圾标识方法：

+ 跟踪式(tracing)GC：使用可达性算法来找寻存活对象
  + 一般是批量的，大范围内或全局的进行标记
  + 因此实时性低，且额外内存需求高，但吞吐量高
+ 引用计数GC：使用并维护对象的计数器值来判定对象是否是垃圾
  + 一般是局部的，仅针对单个对象及其相关子对象的
  + 因此实时性高，且额外内存需求低，但本身难以处理循环引用

基于能否精确识别对象边界：

+ 保守式GC：无法识别某个内存地址存放的是指针还是数值
  + 这种情况下移动对象会造成不可知的后果，因此不能移动对象
+ 准确式GC：能够准确识别某个内存地址存放的是指针还是数值

## 假设

虽然对于最基本的算法，实现起来并不困难，但使用伪代码更加便于叙述。
+ 本文使用伪代码和少量图形进行解释说明。 
+ 假设内存空间固定且连续， 不考虑与系统交互， 动态申请和回收。
+ 不考虑系统底层的内存映射关系等， 除非注明。
+ 假设所有程序的堆内存部分是以有向图逻辑进行引用，没有例外情况。
+ 不考虑多线程情况，除非额外说明。
+ 假设所有的对象可通过obj.field[x]来得到对象内部结构，一个对象至少有一个field（不同的语言已经有许多种实现方式了）
+ 假设堆内存内，地址一块一块来分，可通过obj.valid获取这一块是否空闲，通过obj.next跳转到邻接的下一个地址块
+ 假设堆内存可通过begin指针指向首块地址，最后一个地址块的.next域为end
