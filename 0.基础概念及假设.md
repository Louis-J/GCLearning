## 什么是GC？

GC--Garbage Collection, 字面意思上说是垃圾回收， 垃圾是什么呢？为什么要回收呢？

### 什么是垃圾？

我的理解--广义的来说， 程序运行阶段会不停的申请资源， 释放资源， 当资源不再使用，但占用的资源未被释放，这些就成为垃圾。 内存，硬盘，网络，这些资源都可能会有许多垃圾。

内存资源的维护难度很高：

+ 对象空间上引用关系复杂(一般可看做有向图结构)
+ 对象时间上使用情况复杂(单线程拥有的对象，多线程共享的变量等)
+ 内存资源总量并不充足

因此难以完全手动管理，容易留下隐患，也难以保证程序的性能，因此内存资源的管理影响到整个程序的运行效率。 一般说的狭义的GC所管理的垃圾仅限于内存垃圾。

### 如何判别哪些是垃圾

可以认为，在某个时间点上，程序能够直接和间接访问的对象都是存活对象，不能访问到且未释放的对象都是垃圾。直接访问的对象即为根节点(GC roots)

GC roots一般包括以下几类对象：
1. 全局变量引用对象
2. 静态变量引用对象
3. 运行栈中直接引用的对象(局部变量)

从GC roots使用深度优先遍历和广度优先遍历可以找到所有其他经过GCroots能够间接访问的对象。这些对象就是存活对象。

## 垃圾回收算法的分类

基于对象是否是垃圾的判别方法：

+ 跟踪式(tracing)GC：使用可达性算法来找寻存活对象
+ 引用计数(reference counting)GC：使用并维护对象的计数器值来判定对象是否是垃圾

基于能否精确识别对象范围：

+ 保守式GC：无法识别某个内存地址存放的是指针还是数值
  + 这种情况下移动对象会造成不可知的后果，因此不能移动对象
+ 准确式GC：能够准确识别某个内存地址存放的是指针还是数值

## 假设

+ 本文使用伪代码和图形进行解释说明。 
+ 假设内存空间固定且连续， 不考虑与系统交互， 动态申请和回收。
+ 不考虑系统底层的内存映射关系等， 除非注明。
+ 假设所有程序的堆内存部分是以有向图逻辑进行引用。
+ 假设所有的对象可通过obj.field[x]来得到对象内部结构，一个对象至少有一个field（不同的语言已经有许多种实现方式了）
+ 假设堆内存内，地址一块一块来分，可通过obj.valid获取这一块是否空闲，通过obj.next跳转到邻接的下一个地址块
+ 假设堆内存可通过begin指针指向首块地址，最后一个地址块的.next域为end