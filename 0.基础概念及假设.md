## 什么是GC？

GC--Garbage Collection, 字面意思上说是垃圾回收， 垃圾是什么呢？为什么要回收呢？

### 什么是垃圾？

我的理解--广义的来说， 程序运行阶段会不停的申请资源， 释放资源， 当资源不再使用，但占用的资源未被释放，这些就成为垃圾。 常用的垃圾有，内存， 硬盘， 网络等等。 

内存资源由于内部引用关系复杂(可能存在环的有向图结构)， 所有权关系复杂(有静态资源， 有多个线程共享的资源)， 手动管理时风险大(各种内存问题严重影响程序稳定性)， 且和性能息息相关， 因此内存管理影响到整个程序的运行效率。 一般说的狭义的GC所管理的垃圾仅限于内存垃圾。

## 垃圾回收算法的分类

基于垃圾标识方法：

+ 跟踪式(tracing)GC：使用可达性算法来找寻存活对象
+ 引用计数GC：使用并维护对象的计数器值来判定对象是否是垃圾

基于能否精确识别对象边界：

+ 保守式GC：无法识别某个内存地址存放的是指针还是数值
  + 这种情况下移动对象会造成不可知的后果，因此不能移动对象
+ 准确式GC：能够准确识别某个内存地址存放的是指针还是数值

## 假设

+ 本文使用伪代码和图形进行解释说明。 
+ 假设内存空间固定且连续， 不考虑与系统交互， 动态申请和回收。
+ 不考虑系统底层的内存映射关系等， 除非注明。
+ 假设所有程序的堆内存部分是以有向图逻辑进行引用。
+ 假设所有的对象可通过obj.field[x]来得到对象内部结构，一个对象至少有一个field（不同的语言已经有许多种实现方式了）
+ 假设堆内存内，地址一块一块来分，可通过obj.valid获取这一块是否空闲，通过obj.next跳转到邻接的下一个地址块
+ 假设堆内存可通过begin指针指向首块地址，最后一个地址块的.next域为end