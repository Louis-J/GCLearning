## 缓存兼容

现代CPU有多级缓存结构，这是利用局部性原理提高性能而应用的。一般来说，由于缓存常常是批量读入，而逻辑关系上相近的对象互相调用的可能性会更大，因此将逻辑上相近的对象安排至相近的位置，可以提高性能。针对可以移动对象的GC，可以尽量将逻辑上相近的对象安排至相近的位置。

举例：

+ 前述复制算法有递归和非递归的实现，显然递归的实现更容易让逻辑相近对象的位置相近。如果担心递归导致栈溢出的情况又想达到位置相近的效果，可尝试用栈结构将算法改写成非递归模式，也可以达到同样的效果。

+ 测试1: 随机生成一个序列nums, 并逐个加入AVL字典树a1; 将排序后的nums数据逐个加入AVL字典树a2; 在本机4800h上查找效率差别在1%(win, gcc)~2%(linux, gcc)之间

+ 测试2: 对一个较大的多维数组，分别使用先外层后内层，和先内层后外层的顺序遍历；数组大小小于cpu缓存大小时，差距不明显，当超出cpu缓存大小后，逐渐可以达到8倍(总大小4g左右)

显然，当访问的跨度小于缓存时，差距不明显，访问跨度大大超出缓存时，性能有明显下降。可以预想若访问跨度超出内存，导致频繁的交换时，此时由于硬盘的瓶颈会导致CPU性能无法发挥。

## 多分区的GC

当程序占用内存较大时，如果整体只有一个分区，那么GC导致的暂停时间就会非常长，最简单的方法就是使用多个分区进行GC，这样可以大大降低暂停时间。

同时此处以一个简单的例子，介绍一些后面会用到的技术。

### 最简单的多区GC

实际上对于原始的复制算法，可以非常简单的改进为多分区的GC。假设将堆内存分为10个相等大小的区，标记为0-9，则内存分配时依次向后移动指针，当有9个分区被填满时就进行GC。

+ 假设a分区为空分区，则此次清理第b分区，b=(a+9)%10。
+ 从根节点进行查找，所有在b分区的存活对象复制到a分区。
+ 更新指针，然后清理b分区。

但是每次还是会从根进行查找，每次查找过程开销并没有减少，查找次数却成倍增长，总开销增加。因此吞吐量有很大改进空间。

### 改进-使用记忆集和写屏障

如果针对每个分区建立一个记忆集(remember set)用来记录下所有由其他分区中的对象引用到此分区的情况，那么查找时只需要查找根节点到此分区的直接引用、记忆集中的对象到此分区的直接引用、分区内的对象到此分区的直接引用即可，大大降低了查找开销。

+ 记忆集指向的是外部指向此分区的对象，否则当外部对象不再指向此分区时，难以清理记忆集的内容。
+ 需要使用写屏障技术。当程序运行时所有堆间引用的建立和变化，要检测变化后的引用是否是跨区的，若是跨区引用需要写入对应分区的记忆集。

由于写引用操作相对并不多，因此加入写屏障的额外开销并不大。

### 改进-使用卡表和写屏障

实际上记忆集仍然有一些缺点，如总大小不固定，可能会溢出，查找时间不确定等。由此引申出卡表技术，解决这方面的问题。
> Wilson-Moher
对于每个区，可以每128字节用1bit标识是否有跨代引用，仅需整个区的1/1024空间即可记录区内跨代引用的信息，因此空间开销和写入屏障的时间开销大大减少。
+ 使用写屏障技术，将有跨代引用的对应的标识位记为1(变脏)。
+ 每次GC前，扫描所有的区的卡表中的脏卡，将有跨代引用的对象加入到全局的GC roots中并清理卡表。
+ 扫描时若GC roots中某个本来是跨代引用的对象不再有跨代引用，也可以清理出GC roots。

## 增量操作

针对最大暂停时间的要求，可以通过将一次性的STW操作分为多次增量执行，降低程序的最大响应时间。

### 三色标记算法

三色标记算法是一个方便进行查找的辅助技术。通过给每个对象划定'颜色'，就可以清晰明了的标识当前状态。三种颜色如下：
+ 白：未搜索
+ 灰：正在搜索
+ 黑：搜索完成
一开始所有对象都为白色。搜索时，建立一个栈或队列，将根对象放入队列并涂灰；使用DFS或BFS进行搜索，每次取出一个对象，并将未搜索过的子对象加入队列，当此对象的所有子对象都涂灰或涂黑，这个对象就搜索完毕。新对象入队时涂灰，搜索完出队时涂黑。最后，所有对象都是黑色或白色，其中黑色为存活对象，白色为垃圾。

具体的算法随着使用的GC算法不同而改变，颜色的表示方法也很多样，过程也稍有区别。

下面以增量式的标记-清除为例简单介绍。

### 整体步骤

```bash
// phase: 当前的阶段
// s: 增量操作的状态及临时变量
mark_sweep_incremental(var roots, var begin, var end, var phase, var s) {
    if(phase == init) {
        root_scan(roots, s)
        phase = mark
    } else if(phase == mark) {
        mark_phase_incremental(s)
        if(s.empty())
            phase = sweep
    } else {
        sweep_phase_incremental(s, end)
        if(s == end)
            phase = init
    }
}
root_scan(var roots, var s) {
    s = stack()
    for(var r : roots) {
        s.append(r)
        r.color = gray
    }
}
mark_phase_incremental(var s) {
    var i = 0
    while(!s.empty() && i < MARK_INC_MAX) {
        var obj = s.pop()
        for(var f : obj.fields) {
            if(f.color == white) {
                s.append(f)
                f.color = gray
            }
        }
        obj.color = black
        i++
    }
}
sweep_phase_incremental(var s, var end) {
    var i = 0
    while(s != end && i < SWEEP_INC_MAX) {
        var next = s + s.capacity
        if(s.color == white) {
            sweep(s)
        } else {
            s.color = white
        }
        s = next
        i++
    }
}
```

实际相比于原始的标记-清除，似乎变化不大。但仅仅如此的话是不能运行的，因为两次增量操作之间的程序运行过程，有可能导致引用关系的改变，进而导致错误释放及遗漏，引发崩溃。因此，需要通过写屏障来记录变化，后续的增量操作才能正确应对。

```bash
// 使用Steele算法中的写入屏障，此法相对于原Dijkstra的写入屏障降低了减少了重复搜索情况
// > Steele 1975 Guy L. Steele, Jr., Multiprocessing compactifying garbage collection, Communications of the ACM, v.18 n.9, p.495-508, Sep. 1975

write_barrier(var oldobj, var newobj, var phase, var s) {
    if(phase == mark) {
        if(oldobj.color != white && newobj.color == white) {
            s.append(newobj)
            newobj.color = gray
    }
    ...
}
```

此外，在sweep增量操作之间，新分配的对象需要涂上合适的颜色，防止错误的释放及错误的标记。 

```bash
new_obj(var size, func construct, var phase, var s) {
    obj = construct(malloc(size))
    if(phase == SWEEP && newobj >= s) {
        s.color = black
    } else {
        s.color = white
    }
    return obj
}
```

写入屏障只考虑了对象从垃圾变为存活对象的情况，没有考虑对象从存活对象变为垃圾的情况，一定程度上会保留一些垃圾；不过这些垃圾也会在下一次GC后清理掉。

实际上具体实现时可以进行改动，如使用一个bit标记颜色，0位白色，1且在队列中为灰色，1且不再队列中为黑色; 针对写入屏障，也有许多不同版本。一般根对象的标记过程比较快，可以不用考虑根对象的增量式扫描。

### 优缺点

优点

+ 对吞吐量和回收效果影响较小的情况
+ 大大改善平均暂停时间

缺点
+ 一旦内存不足仍然会引发完全的GC
+ 而且对于何时进行增量回收的规则也需要考虑
+ 如果算法需要移动对象，则仅有写屏障下难以处理
  + 由于对象已经可能移动，但引用未更新导致访问旧的数据
  + 需要增加读屏障处理，但读操作一般远多于写操作，因此可能影响吞吐量

## 分代式GC

假设一个程序可以永久运行，并且会不断创建和销毁对象，而内存又是有限的，那么可以看做100%的对象都会回收，大部分对象并不会存活太长时间。因此对象的存活时间和比例可以类比于泊松分布(相似，但并不完全一样)，许多人已经研究和复现过这个现象。

针对Java语言实际测试，绝大多数对象都是很快死亡的，适合使用复制算法；少部分对象会长期甚至永久使用，适合使用标记-清除算法。如果两者结合，针对不同对象使用不同算法，就能提高性能。这就是分代式GC(Generational GC)

这里介绍David Ungar的经典分代式GC(为便于理解使用java中的名词而非原论文)。
> Generation Scavenging: A Non-disruptlve High Perfornm.nce Storage Reclamation Algorithm
> https://www.cs.purdue.edu/homes/hosking/690M/p157-ungar.pdf

+ 对象有年龄标记，用来区分年轻对象和老年对象
+ 老年代
   + 一个old代：空间很大，存放新建的大对象和年轻代中晋升的过来的对象。
     + 使用标记清除算法
     + 使用remembered set存储从老年代到年轻代的跨代引用，作为避免Minor GC要从老年代的GC roots开始扫描。
+ 年轻代
  + 一个eden代：空间较大，所有新创建对象都分配在此。
  + 两个survivor spaces：空间较小且一致且标记为from和to
    + 一旦eden满了，就引发Minor GC即年轻代的GC
    + 将eden和from中的存活对象年龄增加1，年龄在阈值内的复制到to空间；年龄在阈值外的以及超出to空间范围的复制到old代。
    + 清除eden和from，将from和to互换。

原论文中和当时一些其他方法做了对比，相对于原始的标记清除法，无论是GC的开销，暂停时间，内存占用都有较大改善。而相对于延迟引用计数法，在内存占用是5倍情况下，GC的开销仅有1/10，互有优劣。总体来说是一个非常经典的算法。

## 引用计数法的改进

### 针对循环引用缺陷

#### 方法1：

在准确式GC情况下，可以和跟踪式GC算法结合，处理循环引用问题

##### 例如：

1. 引入标记-清除算法，标记存活和死亡对象，即可处理循环引用问题。
2. 使用分代式GC，老年代使用标记-清除算法，循环引用的对象会在进入老年代后被清理。

##### 局限性：

+ 引入跟踪式GC算法中的标记步骤，增加了最大暂停时间问题

#### 方法2：

循环引用问题仅存在于有向有环图的引用结构中。如果引用结构中没有环，则不会出现循环引用问题。

通过对程序本身设立一定的规则，不要出现环，可以较为优雅得解决。

##### 例：

+ C++要求程序员人工判定哪里有出现环的可能性，并通过无所有权的std::weak_ptr手工解决。由于一定需要手工解决，且编译时不能自动判定，因此并不能保证没有循环引用产生，且难以排查。

+ Rust通过生命周期判定来解决。通过编译时对对象的生命周期判定，和运行时的所有权传递的规则，理论上可以做到一定不会出现循环引用。
  + 由于限制了编程规则，有环情况无法编译通过，或运行时无法获取对象所有权。处理复杂情况时使用unsafe块来阻止编译器的安全性检查，因此将不安全情况限制在unsafe块内，划分了安全和不安全的边界，使安全稳定、灵活性、性能得以兼顾。
  + 为了性能、习惯、方便等原因，部分不安全的方法依然在safe范围内。如使用borrow_mut时仍然有可能在safe块内制造出循环引用。因此编写时仍需注意这些问题。

##### 局限性：

+ 要求语言中程序员可以手动控制内存，且增加了风险(仍然可能出现循环引用情况)。
+ 针对如复杂引用链等情况需要编译前静态分析和保证，加大程序员的工作。
+ 随着程序占用内存不断增大，内存问题排查难度急剧增加。

### 针对计数器增减的开销

解决计数器增减开销主要可以考虑两个方面：多线程环境下的原子操作计数器增减开销较大；可以优化算法减少GCroots直接引用对象的计数器增减次数。

#### 方法1：

许多编译器和虚拟机有**逃逸分析**特性，运行前静态分析或动态分析，判定每个变量的生存周期是否在当前函数内或当前线程内：
+ 若生存周期只在当前函数内的可以在当前函数的运行栈上申请和释放，没有计数器增减开销。
  + go实现了编译期静态的逃逸分析，openjdk实现了jit动态的逃逸分析。
+ 若在堆上申请释放，但仅仅局限于当前线程内的可以使用非原子操作的计数器增减，减小开销。
  + 一般由操作系统保证线程切换时的缓存失效和刷新，因此即使有线程切换情况，也可以认为单线程下非原子操作的计数器增减也是安全的。

#### 方法2：

使用延迟引用计数法。此方法由Deutsch和Bobrow提出，他们认为大多的增减操作出现在GCroots直接引用对象上，因此可以通过延迟GCroots直接引用对象的增减操作，减少开销。具体做法如下：
+ 对GCroots直接引用的对象的操作时不进行计数器增减，且所有为计数器值为0的对象暂时不释放
+ 内存不足时：
  + 先将GCroots直接引用的对象的计数器全部加一，此时计数器值为0的对象一定为垃圾
  + 清理所有计数器值为0的垃圾对象
  + 将GCroots直接引用的对象的计数器全部减一
  + 同时可以配合引入标记-清除算法，处理循环引用问题

##### 优点：

+ smalltalk某一版中实现，发现减小了90%的计数器增减操作，相比立即回收的原始RC算法大大减少了开销。

##### 缺点：

+ 和跟踪式GC一样，清理操作都为批处理而非单个处理
  + 增加了最大暂停时间问题
  + 增加了内存开销(ungar论文中提到)

### 针对计数器内存占用和值溢出的缺陷

计数器会占用一定内存，考虑到字节对齐问题，一般32位系统下每个对象会多出4字节用于存放计数器值，64位系统下为8字节，且计数器增减时会有二次取址(一般计数器放在指向的对象内)；而若将计数器占用内存缩小，如仅1个字节，又会出现溢出的可能(第256个引用同时指向一个对象时，若计数器值增加则会溢出变为0)，导致错误释放，以致出现严重问题。

#### 方法1

引入追踪式gc，计数器增多到一定值后，就不再增减，完全交给追踪式gc处理。

此方法下，仍然有空间占用问题，但不会出现计数器溢出导致的严重问题，也能处理循环引用等问题。

#### 方法2

使用1个bit的引用计数：
+ 计数器占用1位，0代表1个对象指向自身，1代表2个或以上的对象指向自身。释放对象时，计数器位0可以当场释放，计数器为1就等待跟踪式GC的释放
+ 由于仅仅占用1位的特殊情况，可以将计数器放入指针本身如指针的最高位。因此计数器存放在指针而非对象，计数器增减时不会有二次跳转的开销。
+ 此方法实际是方法1的极端情况

优点：

+ 实际程序中单个引用的对象情况很多，追踪式GC的并没有承受完全大的压力。
+ 计数器放入指针内部，计数器增减步骤简单，开销也小。

缺点：

+ 需要操作系统支持，保证申请的地址指针第一位为固定值
+ 32位下单个程序最大内存空间降为2g(由于页表机制，系统本身仍然可以管理足够大的内存)
+ 跟踪式GC的压力相对加大，可能造成GC性能瓶颈，需要对跟踪式GC部分进行优化和配合

