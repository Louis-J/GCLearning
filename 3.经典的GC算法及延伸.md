## 缓存兼容

现代CPU有多级缓存结构，这是利用局部性原理提高性能而应用的。一般来说，由于缓存常常是批量读入，而逻辑关系上相近的对象互相调用的可能性会更大，因此将逻辑上相近的对象安排至相近的位置，可以提高性能。针对可以移动对象的GC，可以尽量将逻辑上相近的对象安排至相近的位置。

举例：

+ 前述复制算法有递归和非递归的实现，显然递归的实现更容易让逻辑相近对象的位置相近。如果担心递归导致栈溢出的情况又想达到位置相近的效果，可尝试用栈结构将算法改写成非递归模式，也可以达到同样的效果。

+ 做一个简单的测试: 随机生成一个序列nums, 并逐个加入AVL字典树a1; 将排序后的nums数据逐个加入AVL字典树a2; 在本机4800h上查找效率差别在1%(win, gcc)~2%(linux, gcc)之间

## 引用计数改进

### 针对循环引用缺陷

在准确式GC情况下，可以和跟踪式GC算法结合，处理循环引用问题

#### 例如：

1. 和标记-清除算法法结合，标记存活和死亡对象，即可处理循环引用问题。
2. 使用分代式GC，老年代使用标记-清除算法，循环引用的对象会在进入老年代后被清理。

#### 局限性：

+ 引入跟踪式GC算法，增加了最大暂停时间问题

### 针对

## 多种GC算法结合

标记-清除和标记-压缩结合

引用计数和GC结合

## 分代回收

针对Java语言实际测试，绝大多数对象都是很快死亡的，适合使用复制算法；少部分对象会长期甚至永久使用，适合使用标记-清除算法。如果两者结合，针对不同对象使用不同算法，就能提高性能。

## 增量回收

如果堆大小达到一定程度，回收的暂停时间就会过长，系统的响应时间也无法保证，因此可以使用增量式的回收方式，降低因最大暂停时间带来的影响。

## 系统内存管理

硬件和操作系统的内存管理

linux系统内的内存管理

malloc内存管理

## 划分Rigion

